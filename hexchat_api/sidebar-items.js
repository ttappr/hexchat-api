initSidebarItems({"constant":[["IRC_BEEP",""],["IRC_BLACK",""],["IRC_BOLD",""],["IRC_CYAN",""],["IRC_GRAY",""],["IRC_GREEN",""],["IRC_HIDDEN",""],["IRC_ITALICS",""],["IRC_LIGHT_GRAY",""],["IRC_LIGHT_GREEN",""],["IRC_MAGENTA",""],["IRC_MAROON",""],["IRC_NAVY",""],["IRC_OLIVE",""],["IRC_ORIG_ATTRIBS",""],["IRC_PURPLE",""],["IRC_RED",""],["IRC_REVERSE_COLOR",""],["IRC_ROYAL_BLUE",""],["IRC_TEAL",""],["IRC_UNDERLINE",""],["IRC_WHITE",""],["IRC_YELLOW",""]],"enum":[["ChanFlag","Channel flags."],["ChanType","Channel types."],["ContextError","The `Context` functions may encounter an error when invoked depending on whether the network name and channel name they're bound to are currently valid. "],["DccStatus","DCC status values."],["DccType","DCC action type."],["Eat","The return value for client plugin callbacks."],["FD","File descriptor types."],["FieldValue","Field Data TypesString    - A string has been returned. The enum item holds its value.Int       - Integer value.Pointer   - This will be updated to be Context soon.Time      - Holds a `time_t` numeric value."],["HexchatError","Errors generated directly from the main Object, `Hexchat`."],["IgnFlag",""],["ListError","Errors`UnknownField` - indicates a field was asked for that the current list items don't have. This value is a tuple holding the name of the requested field.`UnknownType`  - indicates Hexchat reported a data type that it shouldn't have - this should never happen, unless Hexchat is bugging out, or there's been a modification to Hexchat's API - which is unlikely. This tuple holds the type that Hexchat returned as the type of the requested field.`NotStarted`   - This indicates field names were accessed before the iterator had been. started. `next()` needs to be invoked before the fields of the current item can be accessed."],["PrefValue","Represents the values that can be accessed using the prefs functions of the `Hexchat` object (`hc.pluginpref_get()`, `hc.pluginpref_get()`, etc.). The enumeration enables the typing of the values stored and retrieved."],["Priority","The priorty for a given callback invoked by Hexchat."],["StripFlags","Used by the `hexthat.strip()` function to determine what to strip from the target string."],["UserData","Represents the user data that is provided to callbacks when they're invoked. A `UserData` object is registered with the callback using one of the hook commands. The user data can be virtually any type that implements the `Any` trait capable of being downcast to its original type. There are four variants for the user data. Which one to use depends on how the callback user data is shared. If the data is unique to one callback, then `BoxedData` should be enough. For single threaded sharing among more than one callback, `SharedData` will do the trick. If, for any odd sort of reason threading somehow becomes relevant to the user data object, `SyncData` would be the variant to use."]],"fn":[["lib_get_info","This function sets Hexchat's character pointer pointer's to point at the pinned buffers holding info about a plugin. Not to be called by plugin authors - it's only public because `dll_entry_points()` generates code that calls this."],["lib_hexchat_plugin_deinit","Invoked indirectly while a plugin is being unloaded. This function will call the deinitialization function that was registered using the `dll_entry_points()` macro. It will also unhook all the callbacks currently registered forcing them, and their closure state, to drop and thus clean up. Plugin authors should not call this - it's only public  because `dll_entry_points()` generates code that needs this."],["lib_hexchat_plugin_get_info","Called indirectly when a plugin is loaded to get info about it. The plugin author shouldn't invoke this fuction - it's only public because the `dll_entry_points()` macro generates code that calls this. This function calls the client plugin's `plugin_get_info()` indirectly to obtain the persistent plugin info strings that it sets the paramters to."],["lib_hexchat_plugin_init","Called indirectly while a plugin is being loaded. The plugin author shouldn't invoke this fuction - it's only public because the `dll_entry_points()` macro generates code that calls this."],["main_thread","Executes a closure from the Hexchat main thread. This function returns immediately with an AsyncResult object that can be used to retrieve the result of the operation that will run on the main thread."],["main_thread_once","Serves the same purpose as `main_thread()` but takes a `FnOnce()` callback instead of `FnMut()`. With the other command, the callback will hold its state between uses. In this case, the callback will be newly initialized each time this command is invoked."]],"macro":[["cbuf","`&str -> *const c_char`"],["dll_entry_points","`dll_entry_points()` makes it very easy to set up your plugin's DLL interface required by the Hexchat loader. This macro generates the necessary DLL entry points that Hexchat looks for when a DLL is being loaded. Normal Rust functions having the required signatures can be passed to the macro like so:"],["outp","Reduces the syntax required to output formatted text to the current hexchat window. Internally it invokes  `hexchat.print(&format!(\"<format-string>\", arg1, arg2, ...)`. Using the macro, this becomes  `outp!(hc, \"<format_string>\", arg1, arg2, ...)`. To print from another  thread `outpth!()` can be used."],["outpth","Similar to `outp!()`, that can be used from spawned threads to print to the active Hexchat window. This should not be invoked from the Hexchat main thread."]],"struct":[["AsyncResult","A result object that allows callbacks operating on a thread to send their return value to a receiver calling `get()` from another thread. Whether return data needs to be transferred or not, this object can be used to wait on the completion of a callback, thus providing synchronization between threads."],["Context","Any channel in Hexchat has an associated IRC network name and channel name. The network name and channel name are closely associated with the Hexchat concept of contexts. Hexchat contexts can also be thought of as the  tabs, or windows, open in the UI that have the user joined to their various \"chat rooms\". To access a specific chat window in Hexchat, its context  can be acquired and used. This library's `Context` objects represent the Hexchat contexts and can be used to interact with the specific  channels/windows/tabs that he user has open. For instance if your plugin needs to output only to specific channels, rather than the default window (which is the one currently open) - it can acquire the appropriate context using `Context::find(\"some-network\", \"some-channel\")`, and use the object returned to invoke a command, `context.command(\"SAY hello!\")`, or print,  `context.print(\"Hello!\")`, or perform other operations."],["EventAttrs","Mirrors the C struct for `hexchat_event_attrs`. It holds the timestamps for the callback invocations for callbacks registered using  `hexchat_print_attrs()`, and similar commands."],["Hexchat","This struct mirrors the C Hexchat struct passed to the plugin from Hexchat when the plugin is loaded. Hexchat's API is implemented as a struct holding callbacks to its native functions. Don't modify this struct, unless there has been a change to the layout of it in the Hexchat C code base."],["Hook","A wrapper for Hexchat callback hooks. These hooks are returned when  registering callbacks and can be used to unregister (unhook) them. `Hook`s can be cloned to share a reference to the same callback hook."],["ListIterator","The `ListIterator` wraps the list pointer and related functions of Hexchat. It provides are more Rust OO interface. The iterator returns clones of itself that can be used to access the current list item's fields through `get_field()`. The list iterator object is internally a smart pointer, among other things. You can clone it if you need multiple references to a list."],["Plugin","Represents a created plugin entry. Plugins that embed other language interpreters and load plugins written in those languages can have Hexchat look as if the loaded scripts are actual plugins. By creating a `Plugin` object for such a script, an entry is made in Hexchat's list of loaded plugins. When one of these scripts is unloaded, the fictitious plugin entry can be removed from Hexchat by dropping the associated `Plugin` object."],["PluginInfo",""]],"type":[["DeinitFn","The signature for the deinit function plugin authors need to register using `dll_entry_points!()`."],["InfoFn","The signature of the info function plugin authors need to register using `dll_entry_points!()`."],["InitFn","The signature for the init function that plugin authors need to register using `dll_entry_points!()`."]]});